# -*- coding: utf-8 -*-
"""EDA

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fOh1-EK-TzxtgkZi1tXZpCFsVWy6xWgs

# Librerías
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import plotly.express as px
import plotly.graph_objects as go
import seaborn as sns
# import geopandas as gpd
from shapely.geometry import Point, Polygon
import math

"""# Carga de Datos"""

# Circuitos
circuitos = pd.read_csv("https://raw.githubusercontent.com/tomipegu/f1_visualizations/Datasets/circuits.csv")
# Resultados Constructores
resultados_constructores = pd.read_csv("https://raw.githubusercontent.com/tomipegu/f1_visualizations/Datasets/constructor_results.csv")
# Standings Constructores
standing_constructores = pd.read_csv("https://raw.githubusercontent.com/tomipegu/f1_visualizations/Datasets/constructor_standings.csv")
# Constructores
constructores = pd.read_csv("https://raw.githubusercontent.com/tomipegu/f1_visualizations/Datasets/constructors.csv")
# Standings Conductores
standing_conductores = pd.read_csv("https://raw.githubusercontent.com/tomipegu/f1_visualizations/Datasets/driver_standings.csv")
# Conductores
conductores = pd.read_csv("https://raw.githubusercontent.com/tomipegu/f1_visualizations/Datasets/drivers.csv")
# Tiempos de Vuelta
tiempos_vuelta = pd.read_csv("https://raw.githubusercontent.com/tomipegu/f1_visualizations/Datasets/lap_times.csv")
# Pit-Stops
pit_stops = pd.read_csv("https://raw.githubusercontent.com/tomipegu/f1_visualizations/Datasets/pit_stops.csv")
# Histórico Qualifying
historico_clasificacion = pd.read_csv("https://raw.githubusercontent.com/tomipegu/f1_visualizations/Datasets/qualifying.csv")
# Histórico Carreras
historico_carreras = pd.read_csv("https://raw.githubusercontent.com/tomipegu/f1_visualizations/Datasets/races.csv")
# Historico Resultados
historico_resultados = pd.read_csv("https://raw.githubusercontent.com/tomipegu/f1_visualizations/Datasets/results.csv")
# Histórico Temporadas
historico_temporadas = pd.read_csv("https://raw.githubusercontent.com/tomipegu/f1_visualizations/Datasets/seasons.csv")
# Historico Carreras Sprint
historico_sprint = pd.read_csv("https://raw.githubusercontent.com/tomipegu/f1_visualizations/Datasets/sprint_results.csv")
# Glosario Estados de Carrera (finalizado, retirado, avería, etc.)
estados_carrera = pd.read_csv("https://raw.githubusercontent.com/tomipegu/f1_visualizations/Datasets/status.csv")

"""# Exploratory Data Analisis (EDA)

1. Evolucion Tiempos Por Vuelta
"""

# Los mejores tiempos de vuelta vienen reflejados en el archivo 'results.csv'
# 1) Extraemos el mejor tiempo de vuelta para cada conductor en cada carrera
# 2) Para una misma carrera, identificamos el mejor tiempode vuelta entre los conductores
# 3) Extraemos la información de circuito y año de cada carrerra 
# 4) Unificamos la información en una sola tabla

# Calculando la vuelta rapida de cada carrera
df_resultados = tiempos_vuelta[['raceId', 'driverId', 'milliseconds']]
df_fastest_lap = df_resultados.groupby(['raceId'], as_index = False)['milliseconds'].min()

# Determinando el circuito y el año de cada carrera
df_carreras = historico_carreras[['raceId', 'circuitId', 'year']]

# Unificamos la información en una sola tabla
df_races_and_laps = df_carreras.merge(df_fastest_lap)[['circuitId', 'year', 'milliseconds']]

# Para cada circuito, calculamos la diferencia relativa en los tiempos de 
# vuelta de cada año.

# 1) Ordenamos las entradas por circuto y fecha
df_races_and_laps.sort_values(by=['circuitId', 'year'], inplace=True)
# 2) Eliminamos filas con tiempos de vuelta inválidos
df_races_and_laps.drop(df_races_and_laps[df_races_and_laps['milliseconds'] == "\\N"].index, inplace = True)
# 3) Calculamos la diferencia relativa anual en los tiempos de vuelta de cada circuito
df_races_and_laps['delta'] = df_races_and_laps.groupby(['circuitId'], as_index = False)['milliseconds'].pct_change()
# 4) Eliminamos los valores null
df_races_and_laps.dropna(inplace = True)
# 5) Calculamos la variación media de cada año
df_yearly_delta = df_races_and_laps.groupby(["year"], as_index = False)['delta'].mean()

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline

fig = plt.figure(figsize=(10, 8), dpi=80)
ax = plt.axes()
new_list = range(math.floor(min(df_yearly_delta['year'])), math.ceil(max(df_yearly_delta['year']))+1)
plt.xticks(new_list)


ax.plot(df_yearly_delta['year'].astype(int), df_yearly_delta['delta']);

df_yearly_delta

"""2. Circuitos

Map 1 --> geopandas
"""

# Upload files needed for geopandas map
from google.colab import files
uploaded = files.upload()
map = gpd.read_file("World_Countries.shp")

# Let's convert latitudes and longitudes to points to plot them in the map
crs = {'init':'epsg:4326'}
geometry = [Point(xy) for xy in zip(circuitos['lng'], circuitos['lat'])]

geo_circuitos = gpd.GeoDataFrame(circuitos, crs = crs, geometry = geometry)
geo_circuitos.head()

fig,ax = plt.subplots(figsize=(15,15))
map.plot(ax=ax, alpha=0.4, color = "grey")
geo_circuitos[geo_circuitos['country'] == 'Spain'].plot(ax = ax, markersize = 20, color = "red", marker = "o", label= "Spain")
geo_circuitos[geo_circuitos['country'] != 'Spain'].plot(ax = ax, markersize = 20, color = "blue", marker = "o", label= "Else")
plt.legend(prop={'size':'15'})

"""Map 2 --> plotly.graph_objects"""

# La información de los circuitos viene reflejada en el archivo 'circuits.csv'
# 1) Extraemos la lista de circuitos en los que se ha competido cada año
# 2) Calculamos el número de veces que se ha competido en cada circuito
# 3) Extraemos el año de la última carrera realizada en cada circuito
# 4) Extraemos la localización geográfica de cada circuito
# 5) Representamos los resultados en un Bubble Map. (El tamaño de la burbuja representa el volumen de apariciones en el circuito)

# Extraemos la lista de circuitos en los que se ha corrido cada año
df_circuitos_anuales = historico_carreras[['year', 'circuitId']]

# Calculamos el número de veces que se ha competido en cada circuito
df_carrerasPorCircuito = df_circuitos_anuales.groupby(['circuitId'], as_index = False).count().rename(columns = {'year': 'n_carreras'})

# Extraemos el año de la última carrera realizada en cada circuito
df_carrerasPorCircuito['last_year'] = df_circuitos_anuales.groupby(['circuitId'], as_index = False)['year'].max()['year']

# Extraemos la localización geográfica de cada circuito (latitud, longitud)
df_carrerasPorCircuito = circuitos[['circuitId', 'name', 'lat', 'lng']].merge(df_carrerasPorCircuito, how= 'left', on='circuitId')

# Representamos los resultados con un Bubble Map the Plotly
fig = go.Figure()
    
fig.add_trace(go.Scattermapbox(
        lon = df_carrerasPorCircuito['lng'],
        lat = df_carrerasPorCircuito['lat'],
        text = df_carrerasPorCircuito['name'] + '<br>Nº Carreras: ' + (df_carrerasPorCircuito['n_carreras']).astype(str) + '<br>Última Carrera: ' + (df_carrerasPorCircuito['last_year']).astype(str),
        marker = dict(
            size = df_carrerasPorCircuito['n_carreras'],
            #color = df_carrerasPorCircuito['n_carreras']
        )
    ))


fig.update_layout(
    title = 'Nº Carreras por Circuito [Histórico]',
    showlegend = False,
    mapbox_style='carto-positron',
    margin={"r":0,"t":0,"l":0,"b":0},
    )

fig.show()

"""3. Nacionalidades constructores"""

# Let's see where are the teams from
f = lambda x: pc.country_name_to_country_alpha2(x, cn_name_format="default")
constructores['new'] = df['nationality'].apply(f)

data = [
    go.Pie(
        labels=constructores["nationality"], 
        textinfo='label+percent',
        insidetextorientation='radial', 
        marker_colors = ["lightblue", "mediumseagreen", "gold", "darkorange", "indigo"],
        pull = [0,0,0.1,0,0],
        rotation = 0,
        sort = False
    )
]

layout = go.Layout(title = "Nacionalidad de los constructores")

fig = go.Figure(data = data, layout = layout)

fig.show()

"""4. Número de carreras por año"""

# Let's study the number of races by year
sns.set_theme(style='whitegrid')
fig, axis = plt.subplots(1,1, figsize=(20, 5), sharex=True)

df_races_plot = historico_carreras['year'].value_counts().reset_index()
df_races_plot.columns = ['Year', 'Races']
df_races_plot.rename(columns={'Year' : 'Races'})
df_races_plot.sort_values(by=['Year'], inplace=True)
df_races_plot.sort_values(by=['Year'])

graph = sns.barplot(x=df_races_plot['Year'], y=df_races_plot['Races'], palette="crest")
graph.set(title='Número de carreras por año', xlabel='Año', ylabel='Nº carreras')
graph.set_xticklabels(labels=graph.get_xticklabels(), rotation=90)

max = df_races_plot.describe() * 1.1
max_y = 0

_, max_y_f = graph.get_ylim()
max_y = max_y_f if max_y_f > max_y else max_y
graph.set(ylim=(0, max_y))

fig.show()